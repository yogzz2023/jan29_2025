import os

# Mapping of JSON data types to C++ data types and network conversion functions
DATA_TYPE_MAP = {
    "bool": {"cpp_type": "bool", "convert_func": ""},
    "short": {"cpp_type": "short", "convert_func": "ntohs"},
    "unsigned short": {"cpp_type": "unsigned short", "convert_func": "ntohs"},
    "int": {"cpp_type": "int", "convert_func": "ntohl"},
    "unsigned int": {"cpp_type": "unsigned int", "convert_func": "ntohl"},
    "long": {"cpp_type": "long", "convert_func": "ntohl"},
    "unsigned long": {"cpp_type": "unsigned long", "convert_func": "ntohl"},
    "long long": {"cpp_type": "long long", "convert_func": "ntohll"},
    "unsigned long long": {"cpp_type": "unsigned long long", "convert_func": "ntohll"},
    "float": {"cpp_type": "float", "convert_func": ""},
    "double": {"cpp_type": "double", "convert_func": ""}
}

class FilesCreation:
    def create_header_files(self, data):
        print("Creating class files...")
        library_dir = "Library"
        if not os.path.exists(library_dir):
            os.mkdir(library_dir)

        for class_name, attributes in data.items():
            class_folder = os.path.join(library_dir, class_name)
            if not os.path.exists(class_folder):
                os.mkdir(class_folder)

            header_filename = os.path.join(class_folder, f"{class_name}.h")
            source_filename = os.path.join(class_folder, f"{class_name}.cpp")

            # ---------------- Create Header File (.h) ----------------
            with open(header_filename, "w") as header_file:
                # Header Guards
                header_file.write(f"// File : {class_name}.h // Generated by Django Backend\n")
                header_file.write("#ifndef __{}_H__\n".format(class_name.upper()))
                header_file.write("#define __{}_H__\n\n".format(class_name.upper()))
                
                # Include necessary headers
                header_file.write("#include <stdio.h>\n\n")
                
                # Class definition
                header_file.write(f"class {class_name} {{\n")
                header_file.write("public:\n")

                # Struct definition
                header_file.write("    struct MsgBody {\n")
            
                # Dynamically add attributes
                for attr in attributes:
                    cpp_type = DATA_TYPE_MAP.get(attr["data_type"], {"cpp_type": "unsigned short"})["cpp_type"]
                    header_file.write(f"        {cpp_type} {attr['parameter']}; // Auto-generated\n")

                # Add `print` and `printBrief` functions inside `MsgBody`
                header_file.write("\n        // Print Functions\n")
                header_file.write("        void print(char pstr[], int len);\n")
                header_file.write("        void printBrief(char pstr[], int len);\n")

                header_file.write("    } msg;\n\n")

                # Manually Defined Function Declarations
                functions = [
                    "bool set(unsigned char msg[], unsigned short &size)",
                    "bool decode(unsigned char msg[], unsigned short size)",
                    "bool isValid()",
                    "void ntoh()",
                    "void hton()",
                    "void print(char pstr[], int len)",
                    "void print(FILE *fp)",
                    "void print()",
                    "void printBrief(char pstr[], int len)",
                    "void printBrief(FILE *fp)",
                    "void printBrief()",
                    "void printMin(char pstr[], int len)",

                ]

                for func in functions:
                    print("function : ", f"    {func}")
                    header_file.write(f"    {func};\n")

                header_file.write(f"    {class_name}();\n")  # Constructor

                header_file.write("};\n\n")
                header_file.write("#endif\n")

            print(f"Header file '{header_filename}' created successfully!")

            # ---------------- Create Source File (.cpp) ----------------
            # with open(source_filename, "w") as source_file:
            #     source_file.write(f"// File : {class_name}.cpp // Generated by Django Backend\n")
            #     source_file.write(f"#include \"{class_name}.h\"\n")
            #     source_file.write("#include <string.h>\n")
            #     source_file.write("#include <stdio.h>\n")
            #     source_file.write("#include <stddef.h>\n")
            #     source_file.write("#include <iostream>\n\n")

            #     # Constructor Implementation
            #     source_file.write(f"{class_name}::{class_name}() {{\n")
            #     source_file.write("    memset(&msg, 0, sizeof(msg));\n")
            #     for attr in attributes:
            #         default_value = attr["default"]
            #         source_file.write(f"    msg.{attr['parameter']} = {default_value};\n")
            #     source_file.write("}\n\n")

            #     # ntoh() function
            #     source_file.write(f"void {class_name}::ntoh() {{\n")
            #     for attr in attributes:
            #         convert_func = DATA_TYPE_MAP.get(attr["data_type"], {"convert_func": ""})["convert_func"]
            #         if convert_func:
            #             source_file.write(f"    msg.{attr['parameter']} = {convert_func}(msg.{attr['parameter']});\n")
            #     source_file.write("}\n\n")

            #     # hton() function
            #     source_file.write(f"void {class_name}::hton() {{\n")
            #     source_file.write("    ntoh();\n")
            #     source_file.write("}\n\n")

            #     # Manually Defined Function Implementations
            #     for func in functions:
            #         return_type = func.split()[0]
            #         func_name = func.split()[1].split("(")[0]
            #         source_file.write(f"{func} {{\n")
            #         if return_type == "bool":
            #             source_file.write("    return true;\n")
            #         source_file.write("}\n\n")

            # print(f"Header file '{source_filename}' created successfully!")
        
    def create_cpp_file(self, data):
        library_dir = "Library"
        if not os.path.exists(library_dir):
            os.mkdir(library_dir)

        for class_name, attributes in data.items():
            class_folder = os.path.join(library_dir, class_name)
            if not os.path.exists(class_folder):
                os.mkdir(class_folder)

            source_filename = os.path.join(class_folder, f"{class_name}.cpp")

            with open(source_filename, "w") as source_file:
                source_file.write(f"// File : {class_name}.cpp // Generated by Django Backend\n")
                source_file.write(f"#include \"{class_name}.h\"\n")
                source_file.write("#include <string.h>\n")
                source_file.write("#include <stdio.h>\n")
                source_file.write("#include <stddef.h>\n")
                source_file.write("#include <iostream>\n")

                # Constructor Implementation
                source_file.write(f"{class_name}::{class_name}() {{\n")
                source_file.write("    memset(&msg, 0, sizeof(msg));\n")
                for attr in attributes:
                    default_value = "true" if attr["data_type"] == "bool" and attr["default"] == "1" else \
                                    "false" if attr["data_type"] == "bool" else attr["default"]
                    source_file.write(f"    msg.{attr['parameter']} = {default_value};\n")
                source_file.write("}\n\n")

                # set() function
                source_file.write(f"bool {class_name}::set(unsigned char msgbuf[], unsigned short &size) {{\n")
                source_file.write("    size = sizeof(msg);\n")
                source_file.write("    bool valid = true;\n")
                source_file.write("    hton();\n")
                source_file.write("    memcpy(msgbuf, &msg, sizeof(msg));\n")
                source_file.write("    ntoh();\n")
                source_file.write("    return valid;\n")
                source_file.write("}\n\n")

                # decode() function
                source_file.write(f"bool {class_name}::decode(unsigned char msgbuf[], unsigned short size) {{\n")
                source_file.write("    if (size < sizeof(msg)) return false;\n")
                source_file.write("    memcpy(&msg, msgbuf, sizeof(msg));\n")
                source_file.write("    ntoh();\n")
                source_file.write("    return isValid();\n")
                source_file.write("}\n\n")

                # isValid() function
                source_file.write(f"bool {class_name}::isValid() {{\n")
                source_file.write("    return true;\n")
                source_file.write("}\n\n")

                # ntoh() function
                source_file.write(f"void {class_name}::ntoh() {{\n")
                for attr in attributes:
                    source_file.write(f"    msg.{attr['parameter']} = ntohs(msg.{attr['parameter']});\n")
                source_file.write("}\n\n")

                # hton() function
                source_file.write(f"void {class_name}::hton() {{\n")
                source_file.write("    ntoh();\n")
                source_file.write("}\n\n")

                # print() functions
                source_file.write(f"void {class_name}::print(char pstr[], int len) {{\n")
                source_file.write("    msg.print(pstr, len);\n")
                source_file.write("}\n\n")

                source_file.write(f"void {class_name}::print(FILE *fp) {{\n")
                source_file.write("    const int len = 4096;\n")
                source_file.write("    char str[len];\n")
                source_file.write("    print(str, len);\n")
                source_file.write("    fprintf(fp, \"%s\", str);\n")
                source_file.write("}\n\n")

                source_file.write(f"void {class_name}::print() {{\n")
                source_file.write("    print(stdout);\n")
                source_file.write("}\n\n")

                # printBrief() functions
                source_file.write(f"void {class_name}::printBrief(char pstr[], int len) {{\n")
                source_file.write("    msg.printBrief(pstr, len);\n")
                source_file.write("}\n\n")

                source_file.write(f"void {class_name}::printBrief(FILE *fp) {{\n")
                source_file.write("    const int len = 4096;\n")
                source_file.write("    char str[len];\n")
                source_file.write("    printBrief(str, len);\n")
                source_file.write("    fprintf(fp, \"%s\", str);\n")
                source_file.write("}\n\n")

                source_file.write(f"void {class_name}::printBrief() {{\n")
                source_file.write("    printBrief(stdout);\n")
                source_file.write("}\n\n")

                # printMin() function
                source_file.write(f"void {class_name}::printMin(char pstr[], int len) {{\n")
                source_file.write("    printBrief(pstr, len);\n")
                source_file.write("    char last = ' ';\n")
                source_file.write("    for (int i = len - 1; i > 0; i--) {\n")
                source_file.write("        if (pstr[i] == last && last == ' ') {\n")
                source_file.write("            for (int j = i + 1; j < len; j++) pstr[j - 1] = pstr[j];\n")
                source_file.write("        }\n")
                source_file.write("        last = pstr[i];\n")
                source_file.write("    }\n")
                source_file.write("}\n\n")

                # ---------------- print() Function ----------------
                source_file.write(f"void {class_name}::MsgBody::print(char pstr[], int len) {{\n")
                source_file.write("    char temp[len];\n")
                source_file.write("    temp[0] = '\\0';\n")
                source_file.write("    strncpy(pstr, \"\", len);\n")
                source_file.write(f"    snprintf(temp, len, \"{class_name}:\");\n")
                source_file.write("    strncat(pstr, temp, len-strlen(pstr));\n")
                source_file.write("    strncat(pstr, temp, len-strlen(pstr));\n")
                
                # Dynamically add print lines for attributes
                for attr in attributes:
                    source_file.write(f"    snprintf(temp, len, \"{attr['parameter']}:%d \", (int)this->{attr['parameter']});\n")
                    source_file.write("    strncat(pstr, temp, len-strlen(pstr));\n")

                source_file.write("}\n\n")

                # ---------------- printBrief() Function ----------------
                source_file.write(f"void {class_name}::MsgBody::printBrief(char pstr[], int len) {{\n")
                source_file.write("    char temp[len];\n")
                source_file.write("    temp[0] = '\\0';\n")
                source_file.write("    strncpy(pstr, \"\", len);\n")
                source_file.write("    strncat(pstr, temp, len-strlen(pstr));\n")

                # Dynamically add print lines for attributes
                for attr in attributes:
                    source_file.write(f"    snprintf(temp, len, \"%d \", (int)this->{attr['parameter']});\n")
                    source_file.write("    strncat(pstr, temp, len-strlen(pstr));\n")

                source_file.write("}\n\n")


            print(f"Source file '{source_filename}' created successfully!")

